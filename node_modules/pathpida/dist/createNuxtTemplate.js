"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNuxtTemplate = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const createHash_1 = require("./createHash");
const isIgnored_1 = require("./isIgnored");
const parseQueryFromTS_1 = require("./parseQueryFromTS");
const replaceWithUnderscore_1 = require("./replaceWithUnderscore");
const createMethods = (indent, importName, pathname, trailingSlash) => `${indent}  $url: ` +
    (opt => `(url${opt ? '?' : ''}: { ${importName ? `query${opt ? '?' : ''}: ${importName}${opt ? ' | undefined' : ''}, ` : ''}hash?: string | undefined }${opt ? ' | undefined' : ''})`)(!importName?.startsWith('Query')) +
    ` => ({ path: ${/\${/.test(pathname) ? '`' : "'"}${pathname}${trailingSlash || pathname === '' ? '/' : ''}${/\${/.test(pathname) ? '`' : "'"}${importName ? `, query: url${importName.startsWith('Query') ? '' : '?'}.query as any` : ''}, hash: url${importName?.startsWith('Query') ? '' : '?'}.hash })`;
const parseQueryFromVue = (file) => {
    const fileData = fs_1.default.readFileSync(file, 'utf8');
    const typeName = ['Query', 'OptionalQuery'].find(type => new RegExp(`export (interface ${type} ?{|type ${type} ?= ?{)`).test(fileData));
    if (!typeName)
        return;
    const queryRegExp = new RegExp(`export (interface ${typeName} ?{|type ${typeName} ?= ?{)`);
    const [, typeText, targetText] = fileData.split(queryRegExp);
    const { length } = targetText;
    let cursor = 0;
    let depth = 1;
    while (depth && cursor <= length) {
        if (targetText[cursor] === '}') {
            depth -= 1;
        }
        else if (targetText[cursor] === '{') {
            depth += 1;
        }
        cursor += 1;
    }
    const importPath = targetText.slice(0, cursor).replace(/\r/g, '');
    const importName = `${typeName}_${(0, createHash_1.createHash)(importPath)}`;
    return {
        importName,
        importString: `${typeText.replace(typeName, importName)}${importPath};\n`
    };
};
const createNuxtTemplate = (input, output, ignorePath, trailingSlash = false) => {
    const ig = (0, isIgnored_1.createIg)(ignorePath);
    const imports = [];
    const getImportName = (file) => {
        const result = path_1.default.extname(file).startsWith('.ts')
            ? (0, parseQueryFromTS_1.parseQueryFromTS)(output, file)
            : parseQueryFromVue(file);
        if (result) {
            imports.push(result.importString);
            return result.importName;
        }
    };
    const createPathObjString = (targetDir, importBasePath, indent, url, text, methodsOfIndexTsFile) => {
        indent += '  ';
        const props = fs_1.default
            .readdirSync(targetDir)
            .filter(file => [
            !file.startsWith('-'),
            !/\.s?css$/.test(file),
            !file.endsWith('.d.ts'),
            !(0, isIgnored_1.isIgnored)(ig, ignorePath, targetDir, file)
        ].every(Boolean))
            .sort()
            .map((file, _, arr) => {
            const basename = path_1.default.basename(file, path_1.default.extname(file));
            let valFn = `${indent}${(0, replaceWithUnderscore_1.replaceWithUnderscore)(basename)}: {\n<% next %>\n${indent}}`;
            let newUrl = `${url}/${basename}`;
            if (basename.startsWith('_')) {
                const slug = basename.slice(1);
                const isPassValNullable = basename !== file;
                valFn = `${indent}_${slug}: (${slug}${isPassValNullable ? '?' : ''}: string | number${isPassValNullable ? ' | undefined' : ''}) => ({\n<% next %>\n${indent}})`;
                newUrl = `${url}${isPassValNullable ? `\${${slug} !== undefined ? \`/\${${slug}}\` : ''}` : `/\${${slug}}`}`;
            }
            const target = path_1.default.posix.join(targetDir, file);
            if (fs_1.default.statSync(target).isFile() && basename !== 'index' && !arr.includes(basename)) {
                return valFn.replace('<% next %>', createMethods(indent, getImportName(target), newUrl, trailingSlash));
            }
            else if (fs_1.default.statSync(target).isDirectory()) {
                const indexFile = fs_1.default
                    .readdirSync(target)
                    .find(name => path_1.default.basename(name, path_1.default.extname(name)) === 'index');
                return createPathObjString(target, `${importBasePath}/${file}`, indent, newUrl, valFn.replace('<% next %>', '<% props %>'), indexFile &&
                    createMethods(indent, getImportName(path_1.default.posix.join(target, indexFile)), newUrl, trailingSlash));
            }
            return '';
        })
            .filter(Boolean);
        return text.replace('<% props %>', `${props.join(',\n')}${methodsOfIndexTsFile ? `${props.length ? ',\n' : ''}${methodsOfIndexTsFile}` : ''}`);
    };
    const rootIndexFile = fs_1.default
        .readdirSync(input)
        .find(name => path_1.default.basename(name, path_1.default.extname(name)) === 'index');
    const rootIndent = '';
    let rootMethods;
    if (rootIndexFile) {
        rootMethods = createMethods(rootIndent, getImportName(path_1.default.posix.join(input, rootIndexFile)), '', trailingSlash);
    }
    const text = createPathObjString(input, '.', rootIndent, '', '{\n<% props %>\n}', rootMethods);
    const importsText = imports.filter(i => i.startsWith('import')).join('\n');
    const queriesText = imports.filter(i => !i.startsWith('import')).join('\n');
    return `import type { Plugin } from '@nuxt/types';
${importsText}${importsText && queriesText ? '\n' : ''}
${queriesText}${imports.length ? '\n' : ''}export const pagesPath = ${text};\n\nexport type PagesPath = typeof pagesPath;
`;
};
exports.createNuxtTemplate = createNuxtTemplate;
//# sourceMappingURL=createNuxtTemplate.js.map